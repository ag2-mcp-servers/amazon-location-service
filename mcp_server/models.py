# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T12:28:15+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field, RootModel, SecretStr, confloat, conint, constr


class AccessDeniedException(RootModel[Any]):
    root: Any


class ApiKey(RootModel[SecretStr]):
    root: SecretStr


class ApiKeyAction(RootModel[constr(pattern=r'^geo:GetMap\*$')]):
    root: constr(pattern=r'^geo:GetMap\*$')


class ApiKeyRestrictionsAllowActionsList(RootModel[List[ApiKeyAction]]):
    root: List[ApiKeyAction] = Field(..., max_length=1, min_length=1)


class Arn(
    RootModel[
        constr(
            pattern=r'^arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:([^/].*)?$',
            min_length=0,
            max_length=1600,
        )
    ]
):
    root: constr(
        pattern=r'^arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:([^/].*)?$',
        min_length=0,
        max_length=1600,
    )


class ArnList(RootModel[List[Arn]]):
    root: List[Arn]


class AssociateTrackerConsumerRequest(BaseModel):
    ConsumerArn: Arn


class AssociateTrackerConsumerResponse(BaseModel):
    pass


class BatchGetDevicePositionRequestTrackerNameString(
    RootModel[constr(pattern=r'^[-._\w]+$', min_length=1)]
):
    root: constr(pattern=r'^[-._\w]+$', min_length=1)


class BatchItemErrorCode(Enum):
    AccessDeniedError = 'AccessDeniedError'
    ConflictError = 'ConflictError'
    InternalServerError = 'InternalServerError'
    ResourceNotFoundError = 'ResourceNotFoundError'
    ThrottlingError = 'ThrottlingError'
    ValidationError = 'ValidationError'


class Blob(RootModel[str]):
    root: str


class Boolean(RootModel[bool]):
    root: bool


class CalculateRouteCarModeOptions(BaseModel):
    AvoidFerries: Optional[Boolean] = None
    AvoidTolls: Optional[Boolean] = None


class CalculateRouteMatrixSummaryErrorCountInteger(RootModel[conint(ge=1, le=160000)]):
    root: conint(ge=1, le=160000)


class CalculateRouteMatrixSummaryRouteCountInteger(RootModel[conint(ge=1, le=160000)]):
    root: conint(ge=1, le=160000)


class CalculateRouteSummaryDistanceDouble(RootModel[confloat(ge=0.0)]):
    root: confloat(ge=0.0)


class CalculateRouteSummaryDurationSecondsDouble(RootModel[confloat(ge=0.0)]):
    root: confloat(ge=0.0)


class ConflictException(RootModel[Any]):
    root: Any


class CountryCode(RootModel[constr(pattern=r'^[A-Z]{3}$')]):
    root: constr(pattern=r'^[A-Z]{3}$')


class CountryCodeList(RootModel[List[CountryCode]]):
    root: List[CountryCode] = Field(..., max_length=100, min_length=1)


class DeleteGeofenceCollectionRequest(BaseModel):
    pass


class DeleteGeofenceCollectionResponse(BaseModel):
    pass


class DeleteKeyRequest(BaseModel):
    pass


class DeleteKeyResponse(BaseModel):
    pass


class DeleteMapRequest(BaseModel):
    pass


class DeleteMapResponse(BaseModel):
    pass


class DeletePlaceIndexRequest(BaseModel):
    pass


class DeletePlaceIndexResponse(BaseModel):
    pass


class DeleteRouteCalculatorRequest(BaseModel):
    pass


class DeleteRouteCalculatorResponse(BaseModel):
    pass


class DeleteTrackerRequest(BaseModel):
    pass


class DeleteTrackerResponse(BaseModel):
    pass


class DescribeGeofenceCollectionRequest(BaseModel):
    pass


class DescribeKeyRequest(BaseModel):
    pass


class DescribeMapRequest(BaseModel):
    pass


class DescribePlaceIndexRequest(BaseModel):
    pass


class DescribeRouteCalculatorRequest(BaseModel):
    pass


class DescribeTrackerRequest(BaseModel):
    pass


class DimensionUnit(Enum):
    Meters = 'Meters'
    Feet = 'Feet'


class DisassociateTrackerConsumerRequest(BaseModel):
    pass


class DisassociateTrackerConsumerResponse(BaseModel):
    pass


class DistanceUnit(Enum):
    Kilometers = 'Kilometers'
    Miles = 'Miles'


class Double(RootModel[float]):
    root: float


class GeoArn(
    RootModel[
        constr(
            pattern=r'^arn(:[a-z0-9]+([.-][a-z0-9]+)*):geo(:([a-z0-9]+([.-][a-z0-9]+)*))(:[0-9]+):((\*)|([-a-z]+[/][*-._\w]+))$',
            min_length=0,
            max_length=1600,
        )
    ]
):
    root: constr(
        pattern=r'^arn(:[a-z0-9]+([.-][a-z0-9]+)*):geo(:([a-z0-9]+([.-][a-z0-9]+)*))(:[0-9]+):((\*)|([-a-z]+[/][*-._\w]+))$',
        min_length=0,
        max_length=1600,
    )


class GetDevicePositionHistoryRequestMaxResultsInteger(RootModel[conint(ge=1, le=100)]):
    root: conint(ge=1, le=100)


class GetDevicePositionRequest(BaseModel):
    pass


class GetGeofenceRequest(BaseModel):
    pass


class GetMapGlyphsRequest(BaseModel):
    pass


class GetMapGlyphsRequestFontUnicodeRangeString(
    RootModel[constr(pattern=r'^[0-9]+-[0-9]+\.pbf$')]
):
    root: constr(pattern=r'^[0-9]+-[0-9]+\.pbf$')


class GetMapGlyphsResponse(BaseModel):
    Blob_1: Optional[Blob] = Field(None, alias='Blob')


class GetMapSpritesRequest(BaseModel):
    pass


class GetMapSpritesRequestFileNameString(
    RootModel[constr(pattern=r'^sprites(@2x)?\.(png|json)$')]
):
    root: constr(pattern=r'^sprites(@2x)?\.(png|json)$')


class GetMapSpritesResponse(BaseModel):
    Blob_1: Optional[Blob] = Field(None, alias='Blob')


class GetMapStyleDescriptorRequest(BaseModel):
    pass


class GetMapStyleDescriptorResponse(BaseModel):
    Blob_1: Optional[Blob] = Field(None, alias='Blob')


class GetMapTileRequest(BaseModel):
    pass


class GetMapTileRequestXString(RootModel[constr(pattern=r'\d+')]):
    root: constr(pattern=r'\d+')


class GetMapTileRequestYString(RootModel[constr(pattern=r'\d+')]):
    root: constr(pattern=r'\d+')


class GetMapTileRequestZString(RootModel[constr(pattern=r'\d+')]):
    root: constr(pattern=r'\d+')


class GetMapTileResponse(BaseModel):
    Blob_1: Optional[Blob] = Field(None, alias='Blob')


class GetPlaceRequest(BaseModel):
    pass


class Id(
    RootModel[constr(pattern=r'^[-._\p{L}\p{N}]+$', min_length=1, max_length=100)]
):
    root: constr(pattern=r'^[-._\p{L}\p{N}]+$', min_length=1, max_length=100)


class Integer(RootModel[int]):
    root: int


class IntendedUse(Enum):
    SingleUse = 'SingleUse'
    Storage = 'Storage'


class InternalServerException(RootModel[Any]):
    root: Any


class KmsKeyId(RootModel[constr(min_length=1, max_length=2048)]):
    root: constr(min_length=1, max_length=2048)


class LanguageTag(RootModel[constr(min_length=2, max_length=35)]):
    root: constr(min_length=2, max_length=35)


class LegDistanceDouble(RootModel[confloat(ge=0.0)]):
    root: confloat(ge=0.0)


class LegDurationSecondsDouble(RootModel[confloat(ge=0.0)]):
    root: confloat(ge=0.0)


class ListDevicePositionsRequestMaxResultsInteger(RootModel[conint(ge=1, le=100)]):
    root: conint(ge=1, le=100)


class ListGeofenceCollectionsRequestMaxResultsInteger(RootModel[conint(ge=1, le=100)]):
    root: conint(ge=1, le=100)


class ListGeofencesRequestMaxResultsInteger(RootModel[conint(ge=1, le=100)]):
    root: conint(ge=1, le=100)


class ListKeysRequestMaxResultsInteger(RootModel[conint(ge=1, le=100)]):
    root: conint(ge=1, le=100)


class ListMapsRequestMaxResultsInteger(RootModel[conint(ge=1, le=100)]):
    root: conint(ge=1, le=100)


class ListPlaceIndexesRequestMaxResultsInteger(RootModel[conint(ge=1, le=100)]):
    root: conint(ge=1, le=100)


class ListRouteCalculatorsRequestMaxResultsInteger(RootModel[conint(ge=1, le=100)]):
    root: conint(ge=1, le=100)


class ListTagsForResourceRequest(BaseModel):
    pass


class ListTrackerConsumersRequestMaxResultsInteger(RootModel[conint(ge=1, le=100)]):
    root: conint(ge=1, le=100)


class ListTrackersRequestMaxResultsInteger(RootModel[conint(ge=1, le=100)]):
    root: conint(ge=1, le=100)


class MapStyle(RootModel[constr(pattern=r'^[-._\w]+$', min_length=1, max_length=100)]):
    root: constr(pattern=r'^[-._\w]+$', min_length=1, max_length=100)


class PlaceId(RootModel[str]):
    root: str


class PlaceIndexSearchResultLimit(RootModel[conint(ge=1, le=50)]):
    root: conint(ge=1, le=50)


class Position(RootModel[List[Double]]):
    root: List[Double] = Field(..., max_length=2, min_length=2)


class PositionFiltering(Enum):
    TimeBased = 'TimeBased'
    DistanceBased = 'DistanceBased'
    AccuracyBased = 'AccuracyBased'


class PositionalAccuracyHorizontalDouble(RootModel[confloat(ge=0.0, le=10000.0)]):
    root: confloat(ge=0.0, le=10000.0)


class PricingPlan(Enum):
    RequestBasedUsage = 'RequestBasedUsage'
    MobileAssetTracking = 'MobileAssetTracking'
    MobileAssetManagement = 'MobileAssetManagement'


class PropertyMapKeyString(RootModel[constr(min_length=1, max_length=20)]):
    root: constr(min_length=1, max_length=20)


class PropertyMapValueString(RootModel[constr(min_length=1, max_length=40)]):
    root: constr(min_length=1, max_length=40)


class RefererPattern(
    RootModel[
        constr(
            pattern=r'^([$\-._+!*\x{60}(),;/?:@=&\w]|%([0-9a-fA-F?]{2}|[0-9a-fA-F?]?[*]))+$',
            min_length=0,
            max_length=253,
        )
    ]
):
    root: constr(
        pattern=r'^([$\-._+!*\x{60}(),;/?:@=&\w]|%([0-9a-fA-F?]{2}|[0-9a-fA-F?]?[*]))+$',
        min_length=0,
        max_length=253,
    )


class ResourceDescription(RootModel[constr(min_length=0, max_length=1000)]):
    root: constr(min_length=0, max_length=1000)


class ResourceName(
    RootModel[constr(pattern=r'^[-._\w]+$', min_length=1, max_length=100)]
):
    root: constr(pattern=r'^[-._\w]+$', min_length=1, max_length=100)


class ResourceNotFoundException(RootModel[Any]):
    root: Any


class RouteMatrixEntryDistanceDouble(RootModel[confloat(ge=0.0)]):
    root: confloat(ge=0.0)


class RouteMatrixEntryDurationSecondsDouble(RootModel[confloat(ge=0.0)]):
    root: confloat(ge=0.0)


class RouteMatrixErrorCode(Enum):
    RouteNotFound = 'RouteNotFound'
    RouteTooLong = 'RouteTooLong'
    PositionsNotFound = 'PositionsNotFound'
    DestinationPositionNotFound = 'DestinationPositionNotFound'
    DeparturePositionNotFound = 'DeparturePositionNotFound'
    OtherValidationError = 'OtherValidationError'


class SearchForPositionResultDistanceDouble(RootModel[confloat(ge=0.0)]):
    root: confloat(ge=0.0)


class SearchForTextResultDistanceDouble(RootModel[confloat(ge=0.0)]):
    root: confloat(ge=0.0)


class SearchForTextResultRelevanceDouble(RootModel[confloat(ge=0.0, le=1.0)]):
    root: confloat(ge=0.0, le=1.0)


class SearchPlaceIndexForPositionRequest(BaseModel):
    Language: Optional[LanguageTag] = None
    MaxResults: Optional[PlaceIndexSearchResultLimit] = None
    Position_1: Position = Field(..., alias='Position')


class SearchPlaceIndexForSuggestionsRequestMaxResultsInteger(
    RootModel[conint(ge=1, le=15)]
):
    root: conint(ge=1, le=15)


class SearchPlaceIndexForSuggestionsRequestTextString(RootModel[SecretStr]):
    root: SecretStr


class SearchPlaceIndexForTextRequestTextString(RootModel[SecretStr]):
    root: SecretStr


class SensitiveString(RootModel[SecretStr]):
    root: SecretStr


class ServiceQuotaExceededException(RootModel[Any]):
    root: Any


class Status(Enum):
    Active = 'Active'
    Expired = 'Expired'


class StepDistanceDouble(RootModel[confloat(ge=0.0)]):
    root: confloat(ge=0.0)


class StepDurationSecondsDouble(RootModel[confloat(ge=0.0)]):
    root: confloat(ge=0.0)


class StepGeometryOffsetInteger(RootModel[conint(ge=0)]):
    root: conint(ge=0)


class String(RootModel[str]):
    root: str


class TagKey(
    RootModel[constr(pattern=r'^[a-zA-Z+-=._:/]+$', min_length=1, max_length=128)]
):
    root: constr(pattern=r'^[a-zA-Z+-=._:/]+$', min_length=1, max_length=128)


class TagKeys(RootModel[List[String]]):
    root: List[String] = Field(..., max_length=50, min_length=1)


class TagResourceResponse(BaseModel):
    pass


class TagValue(
    RootModel[constr(pattern=r'^[A-Za-z0-9 _=@:.+-/]*$', min_length=0, max_length=256)]
):
    root: constr(pattern=r'^[A-Za-z0-9 _=@:.+-/]*$', min_length=0, max_length=256)


class ThrottlingException(RootModel[Any]):
    root: Any


class TimeZone(BaseModel):
    Name: String
    Offset: Optional[Integer] = None


class Timestamp(RootModel[datetime]):
    root: datetime


class Token(RootModel[constr(min_length=1, max_length=2000)]):
    root: constr(min_length=1, max_length=2000)


class TravelMode(Enum):
    Car = 'Car'
    Truck = 'Truck'
    Walking = 'Walking'
    Bicycle = 'Bicycle'
    Motorcycle = 'Motorcycle'


class TruckDimensionsHeightDouble(RootModel[confloat(ge=0.0)]):
    root: confloat(ge=0.0)


class TruckDimensionsLengthDouble(RootModel[confloat(ge=0.0)]):
    root: confloat(ge=0.0)


class TruckDimensionsWidthDouble(RootModel[confloat(ge=0.0)]):
    root: confloat(ge=0.0)


class TruckWeightTotalDouble(RootModel[confloat(ge=0.0)]):
    root: confloat(ge=0.0)


class UntagResourceRequest(BaseModel):
    pass


class UntagResourceResponse(BaseModel):
    pass


class UpdateGeofenceCollectionRequest(BaseModel):
    Description: Optional[ResourceDescription] = None
    PricingPlan_1: Optional[PricingPlan] = Field(None, alias='PricingPlan')
    PricingPlanDataSource: Optional[String] = None


class UpdateGeofenceCollectionResponse(BaseModel):
    CollectionArn: Arn
    CollectionName: ResourceName
    UpdateTime: Timestamp


class UpdateKeyResponse(BaseModel):
    KeyArn: Arn
    KeyName: ResourceName
    UpdateTime: Timestamp


class UpdateMapRequest(BaseModel):
    Description: Optional[ResourceDescription] = None
    PricingPlan_1: Optional[PricingPlan] = Field(None, alias='PricingPlan')


class UpdateMapResponse(BaseModel):
    MapArn: GeoArn
    MapName: ResourceName
    UpdateTime: Timestamp


class UpdatePlaceIndexResponse(BaseModel):
    IndexArn: Arn
    IndexName: ResourceName
    UpdateTime: Timestamp


class UpdateRouteCalculatorRequest(BaseModel):
    Description: Optional[ResourceDescription] = None
    PricingPlan_1: Optional[PricingPlan] = Field(None, alias='PricingPlan')


class UpdateRouteCalculatorResponse(BaseModel):
    CalculatorArn: Arn
    CalculatorName: ResourceName
    UpdateTime: Timestamp


class UpdateTrackerRequest(BaseModel):
    Description: Optional[ResourceDescription] = None
    PositionFiltering_1: Optional[PositionFiltering] = Field(
        None, alias='PositionFiltering'
    )
    PricingPlan_1: Optional[PricingPlan] = Field(None, alias='PricingPlan')
    PricingPlanDataSource: Optional[String] = None


class UpdateTrackerResponse(BaseModel):
    TrackerArn: Arn
    TrackerName: ResourceName
    UpdateTime: Timestamp


class ValidationException(RootModel[Any]):
    root: Any


class VehicleWeightUnit(Enum):
    Kilograms = 'Kilograms'
    Pounds = 'Pounds'


class GeofencingV0CollectionsPostRequest(BaseModel):
    CollectionName: constr(pattern=r'^[-._\w]+$', min_length=1, max_length=100) = Field(
        ...,
        description='<p>A custom name for the geofence collection.</p> <p>Requirements:</p> <ul> <li> <p>Contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods (.), and underscores (_). </p> </li> <li> <p>Must be a unique geofence collection name.</p> </li> <li> <p>No spaces allowed. For example, <code>ExampleGeofenceCollection</code>.</p> </li> </ul>',
    )
    Description: Optional[constr(min_length=0, max_length=1000)] = Field(
        None, description='An optional description for the geofence collection.'
    )
    KmsKeyId: Optional[constr(min_length=1, max_length=2048)] = Field(
        None,
        description='A key identifier for an <a href="https://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html">Amazon Web Services KMS customer managed key</a>. Enter a key ID, key ARN, alias name, or alias ARN. ',
    )
    PricingPlan_1: Optional[PricingPlan] = Field(
        None,
        alias='PricingPlan',
        description='No longer used. If included, the only allowed value is <code>RequestBasedUsage</code>.',
    )
    PricingPlanDataSource: Optional[str] = Field(
        None, description='This parameter is no longer used.'
    )
    Tags: Optional[Dict[str, TagValue]] = Field(
        None,
        description='<p>Applies one or more tags to the geofence collection. A tag is a key-value pair helps manage, identify, search, and filter your resources by labelling them.</p> <p>Format: <code>"key" : "value"</code> </p> <p>Restrictions:</p> <ul> <li> <p>Maximum 50 tags per resource</p> </li> <li> <p>Each resource tag must be unique with a maximum of one value.</p> </li> <li> <p>Maximum key length: 128 Unicode characters in UTF-8</p> </li> <li> <p>Maximum value length: 256 Unicode characters in UTF-8</p> </li> <li> <p>Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @. </p> </li> <li> <p>Cannot use "aws:" as a prefix for a key.</p> </li> </ul>',
    )


class GeofencingV0CollectionsCollectionNamePatchRequest(BaseModel):
    Description: Optional[constr(min_length=0, max_length=1000)] = Field(
        None, description='Updates the description for the geofence collection.'
    )
    PricingPlan_1: Optional[PricingPlan] = Field(
        None,
        alias='PricingPlan',
        description='No longer used. If included, the only allowed value is <code>RequestBasedUsage</code>.',
    )
    PricingPlanDataSource: Optional[str] = Field(
        None, description='This parameter is no longer used.'
    )


class GeofencingV0CollectionsCollectionNameDeleteGeofencesPostRequest(BaseModel):
    GeofenceIds: List[Id] = Field(
        ...,
        description='The batch of geofences to be deleted.',
        max_length=10,
        min_length=1,
    )


class GeofencingV0CollectionsCollectionNameListGeofencesPostRequest(BaseModel):
    MaxResults: Optional[conint(ge=1, le=100)] = Field(
        None,
        description='<p>An optional limit for the number of geofences returned in a single call. </p> <p>Default value: <code>100</code> </p>',
    )
    NextToken: Optional[constr(min_length=1, max_length=2000)] = Field(
        None,
        description='<p>The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. </p> <p>Default value: <code>null</code> </p>',
    )


class GeofencingV0ListCollectionsPostRequest(BaseModel):
    MaxResults: Optional[conint(ge=1, le=100)] = Field(
        None,
        description='<p>An optional limit for the number of resources returned in a single call. </p> <p>Default value: <code>100</code> </p>',
    )
    NextToken: Optional[constr(min_length=1, max_length=2000)] = Field(
        None,
        description='<p>The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. </p> <p>Default value: <code>null</code> </p>',
    )


class MapsV0ListMapsPostRequest(BaseModel):
    MaxResults: Optional[conint(ge=1, le=100)] = Field(
        None,
        description='<p>An optional limit for the number of resources returned in a single call. </p> <p>Default value: <code>100</code> </p>',
    )
    NextToken: Optional[constr(min_length=1, max_length=2000)] = Field(
        None,
        description='<p>The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page.</p> <p>Default value: <code>null</code> </p>',
    )


class Configuration(BaseModel):
    Style: Optional[MapStyle] = None


class MapsV0MapsPostRequest(BaseModel):
    Configuration_1: Configuration = Field(
        ...,
        alias='Configuration',
        description='Specifies the map tile style selected from an available provider.',
    )
    Description: Optional[constr(min_length=0, max_length=1000)] = Field(
        None, description='An optional description for the map resource.'
    )
    MapName: constr(pattern=r'^[-._\w]+$', min_length=1, max_length=100) = Field(
        ...,
        description='<p>The name for the map resource.</p> <p>Requirements:</p> <ul> <li> <p>Must contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods (.), and underscores (_). </p> </li> <li> <p>Must be a unique map resource name. </p> </li> <li> <p>No spaces allowed. For example, <code>ExampleMap</code>.</p> </li> </ul>',
    )
    PricingPlan_1: Optional[PricingPlan] = Field(
        None,
        alias='PricingPlan',
        description='No longer used. If included, the only allowed value is <code>RequestBasedUsage</code>.',
    )
    Tags: Optional[Dict[str, TagValue]] = Field(
        None,
        description='<p>Applies one or more tags to the map resource. A tag is a key-value pair helps manage, identify, search, and filter your resources by labelling them.</p> <p>Format: <code>"key" : "value"</code> </p> <p>Restrictions:</p> <ul> <li> <p>Maximum 50 tags per resource</p> </li> <li> <p>Each resource tag must be unique with a maximum of one value.</p> </li> <li> <p>Maximum key length: 128 Unicode characters in UTF-8</p> </li> <li> <p>Maximum value length: 256 Unicode characters in UTF-8</p> </li> <li> <p>Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @. </p> </li> <li> <p>Cannot use "aws:" as a prefix for a key.</p> </li> </ul>',
    )


class MapsV0MapsMapNamePatchRequest(BaseModel):
    Description: Optional[constr(min_length=0, max_length=1000)] = Field(
        None, description='Updates the description for the map resource.'
    )
    PricingPlan_1: Optional[PricingPlan] = Field(
        None,
        alias='PricingPlan',
        description='No longer used. If included, the only allowed value is <code>RequestBasedUsage</code>.',
    )


class Filter(BaseModel):
    KeyStatus: Optional[Status] = None


class MetadataV0ListKeysPostRequest(BaseModel):
    Filter_1: Optional[Filter] = Field(
        None, alias='Filter', description='Options for filtering API keys.'
    )
    MaxResults: Optional[conint(ge=1, le=100)] = Field(
        None,
        description='<p>An optional limit for the number of resources returned in a single call. </p> <p>Default value: <code>100</code> </p>',
    )
    NextToken: Optional[constr(min_length=1, max_length=2000)] = Field(
        None,
        description='<p>The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. </p> <p>Default value: <code>null</code> </p>',
    )


class DataSourceConfiguration(BaseModel):
    IntendedUse_1: Optional[IntendedUse] = Field(None, alias='IntendedUse')


class PlacesV0IndexesPostRequest(BaseModel):
    DataSource: str = Field(
        ...,
        description='<p>Specifies the geospatial data provider for the new place index.</p> <note> <p>This field is case-sensitive. Enter the valid values as shown. For example, entering <code>HERE</code> returns an error.</p> </note> <p>Valid values include:</p> <ul> <li> <p> <code>Esri</code> – For additional information about <a href="https://docs.aws.amazon.com/location/latest/developerguide/esri.html">Esri</a>\'s coverage in your region of interest, see <a href="https://developers.arcgis.com/rest/geocode/api-reference/geocode-coverage.htm">Esri details on geocoding coverage</a>.</p> </li> <li> <p> <code>Grab</code> – Grab provides place index functionality for Southeast Asia. For additional information about <a href="https://docs.aws.amazon.com/location/latest/developerguide/grab.html">GrabMaps</a>\' coverage, see <a href="https://docs.aws.amazon.com/location/latest/developerguide/grab.html#grab-coverage-area">GrabMaps countries and areas covered</a>.</p> </li> <li> <p> <code>Here</code> – For additional information about <a href="https://docs.aws.amazon.com/location/latest/developerguide/HERE.html">HERE Technologies</a>\' coverage in your region of interest, see <a href="https://developer.here.com/documentation/geocoder/dev_guide/topics/coverage-geocoder.html">HERE details on goecoding coverage</a>.</p> <important> <p>If you specify HERE Technologies (<code>Here</code>) as the data provider, you may not <a href="https://docs.aws.amazon.com/location-places/latest/APIReference/API_DataSourceConfiguration.html">store results</a> for locations in Japan. For more information, see the <a href="http://aws.amazon.com/service-terms/">Amazon Web Services Service Terms</a> for Amazon Location Service.</p> </important> </li> </ul> <p>For additional information , see <a href="https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html">Data providers</a> on the <i>Amazon Location Service Developer Guide</i>.</p>',
    )
    DataSourceConfiguration_1: Optional[DataSourceConfiguration] = Field(
        None,
        alias='DataSourceConfiguration',
        description='<p>Specifies the data storage option chosen for requesting Places.</p> <important> <p>When using Amazon Location Places:</p> <ul> <li> <p>If using HERE Technologies as a data provider, you can\'t store results for locations in Japan by setting <code>IntendedUse</code> to <code>Storage</code>. parameter.</p> </li> <li> <p>Under the <code>MobileAssetTracking</code> or <code>MobilAssetManagement</code> pricing plan, you can\'t store results from your place index resources by setting <code>IntendedUse</code> to <code>Storage</code>. This returns a validation exception error.</p> </li> </ul> <p>For more information, see the <a href="https://aws.amazon.com/service-terms/">AWS Service Terms</a> for Amazon Location Service.</p> </important>',
    )
    Description: Optional[constr(min_length=0, max_length=1000)] = Field(
        None, description='The optional description for the place index resource.'
    )
    IndexName: constr(pattern=r'^[-._\w]+$', min_length=1, max_length=100) = Field(
        ...,
        description='<p>The name of the place index resource. </p> <p>Requirements:</p> <ul> <li> <p>Contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods (.), and underscores (_).</p> </li> <li> <p>Must be a unique place index resource name.</p> </li> <li> <p>No spaces allowed. For example, <code>ExamplePlaceIndex</code>.</p> </li> </ul>',
    )
    PricingPlan_1: Optional[PricingPlan] = Field(
        None,
        alias='PricingPlan',
        description='No longer used. If included, the only allowed value is <code>RequestBasedUsage</code>.',
    )
    Tags: Optional[Dict[str, TagValue]] = Field(
        None,
        description='<p>Applies one or more tags to the place index resource. A tag is a key-value pair that helps you manage, identify, search, and filter your resources.</p> <p>Format: <code>"key" : "value"</code> </p> <p>Restrictions:</p> <ul> <li> <p>Maximum 50 tags per resource.</p> </li> <li> <p>Each tag key must be unique and must have exactly one associated value.</p> </li> <li> <p>Maximum key length: 128 Unicode characters in UTF-8.</p> </li> <li> <p>Maximum value length: 256 Unicode characters in UTF-8.</p> </li> <li> <p>Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @</p> </li> <li> <p>Cannot use "aws:" as a prefix for a key.</p> </li> </ul>',
    )


class PlacesV0IndexesIndexNamePatchRequest(BaseModel):
    DataSourceConfiguration_1: Optional[DataSourceConfiguration] = Field(
        None,
        alias='DataSourceConfiguration',
        description='<p>Specifies the data storage option chosen for requesting Places.</p> <important> <p>When using Amazon Location Places:</p> <ul> <li> <p>If using HERE Technologies as a data provider, you can\'t store results for locations in Japan by setting <code>IntendedUse</code> to <code>Storage</code>. parameter.</p> </li> <li> <p>Under the <code>MobileAssetTracking</code> or <code>MobilAssetManagement</code> pricing plan, you can\'t store results from your place index resources by setting <code>IntendedUse</code> to <code>Storage</code>. This returns a validation exception error.</p> </li> </ul> <p>For more information, see the <a href="https://aws.amazon.com/service-terms/">AWS Service Terms</a> for Amazon Location Service.</p> </important>',
    )
    Description: Optional[constr(min_length=0, max_length=1000)] = Field(
        None, description='Updates the description for the place index resource.'
    )
    PricingPlan_1: Optional[PricingPlan] = Field(
        None,
        alias='PricingPlan',
        description='No longer used. If included, the only allowed value is <code>RequestBasedUsage</code>.',
    )


class PlacesV0IndexesIndexNameSearchPositionPostRequest(BaseModel):
    Language: Optional[constr(min_length=2, max_length=35)] = Field(
        None,
        description='<p>The preferred language used to return results. The value must be a valid <a href="https://tools.ietf.org/search/bcp47">BCP 47</a> language tag, for example, <code>en</code> for English.</p> <p>This setting affects the languages used in the results, but not the results themselves. If no language is specified, or not supported for a particular result, the partner automatically chooses a language for the result.</p> <p>For an example, we\'ll use the Greek language. You search for a location around Athens, Greece, with the <code>language</code> parameter set to <code>en</code>. The <code>city</code> in the results will most likely be returned as <code>Athens</code>.</p> <p>If you set the <code>language</code> parameter to <code>el</code>, for Greek, then the <code>city</code> in the results will more likely be returned as <code>Αθήνα</code>.</p> <p>If the data provider does not have a value for Greek, the result will be in a language that the provider does support.</p>',
    )
    MaxResults: Optional[conint(ge=1, le=50)] = Field(
        None,
        description='<p>An optional parameter. The maximum number of results returned per request.</p> <p>Default value: <code>50</code> </p>',
    )
    Position: List[Double] = Field(
        ...,
        description='<p>Specifies the longitude and latitude of the position to query.</p> <p> This parameter must contain a pair of numbers. The first number represents the X coordinate, or longitude; the second number represents the Y coordinate, or latitude.</p> <p>For example, <code>[-123.1174, 49.2847]</code> represents a position with longitude <code>-123.1174</code> and latitude <code>49.2847</code>.</p>',
        max_length=2,
        min_length=2,
    )


class PlacesV0IndexesIndexNameSearchSuggestionsPostRequest(BaseModel):
    BiasPosition: Optional[List[Double]] = Field(
        None,
        description='<p>An optional parameter that indicates a preference for place suggestions that are closer to a specified position.</p> <p> If provided, this parameter must contain a pair of numbers. The first number represents the X coordinate, or longitude; the second number represents the Y coordinate, or latitude.</p> <p>For example, <code>[-123.1174, 49.2847]</code> represents the position with longitude <code>-123.1174</code> and latitude <code>49.2847</code>.</p> <note> <p> <code>BiasPosition</code> and <code>FilterBBox</code> are mutually exclusive. Specifying both options results in an error. </p> </note>',
        max_length=2,
        min_length=2,
    )
    FilterBBox: Optional[List[Double]] = Field(
        None,
        description='<p>An optional parameter that limits the search results by returning only suggestions within a specified bounding box.</p> <p> If provided, this parameter must contain a total of four consecutive numbers in two pairs. The first pair of numbers represents the X and Y coordinates (longitude and latitude, respectively) of the southwest corner of the bounding box; the second pair of numbers represents the X and Y coordinates (longitude and latitude, respectively) of the northeast corner of the bounding box.</p> <p>For example, <code>[-12.7935, -37.4835, -12.0684, -36.9542]</code> represents a bounding box where the southwest corner has longitude <code>-12.7935</code> and latitude <code>-37.4835</code>, and the northeast corner has longitude <code>-12.0684</code> and latitude <code>-36.9542</code>.</p> <note> <p> <code>FilterBBox</code> and <code>BiasPosition</code> are mutually exclusive. Specifying both options results in an error. </p> </note>',
        max_length=4,
        min_length=4,
    )
    FilterCountries: Optional[List[CountryCode]] = Field(
        None,
        description='<p>An optional parameter that limits the search results by returning only suggestions within the provided list of countries.</p> <ul> <li> <p>Use the <a href="https://www.iso.org/iso-3166-country-codes.html">ISO 3166</a> 3-digit country code. For example, Australia uses three upper-case characters: <code>AUS</code>.</p> </li> </ul>',
        max_length=100,
        min_length=1,
    )
    Language: Optional[constr(min_length=2, max_length=35)] = Field(
        None,
        description='<p>The preferred language used to return results. The value must be a valid <a href="https://tools.ietf.org/search/bcp47">BCP 47</a> language tag, for example, <code>en</code> for English.</p> <p>This setting affects the languages used in the results. If no language is specified, or not supported for a particular result, the partner automatically chooses a language for the result.</p> <p>For an example, we\'ll use the Greek language. You search for <code>Athens, Gr</code> to get suggestions with the <code>language</code> parameter set to <code>en</code>. The results found will most likely be returned as <code>Athens, Greece</code>.</p> <p>If you set the <code>language</code> parameter to <code>el</code>, for Greek, then the result found will more likely be returned as <code>Αθήνα, Ελλάδα</code>.</p> <p>If the data provider does not have a value for Greek, the result will be in a language that the provider does support.</p>',
    )
    MaxResults: Optional[conint(ge=1, le=15)] = Field(
        None,
        description='<p>An optional parameter. The maximum number of results returned per request. </p> <p>The default: <code>5</code> </p>',
    )
    Text: SecretStr = Field(
        ...,
        description='The free-form partial text to use to generate place suggestions. For example, <code>eiffel tow</code>.',
    )


class PlacesV0IndexesIndexNameSearchTextPostRequest(BaseModel):
    BiasPosition: Optional[List[Double]] = Field(
        None,
        description='<p>An optional parameter that indicates a preference for places that are closer to a specified position.</p> <p> If provided, this parameter must contain a pair of numbers. The first number represents the X coordinate, or longitude; the second number represents the Y coordinate, or latitude.</p> <p>For example, <code>[-123.1174, 49.2847]</code> represents the position with longitude <code>-123.1174</code> and latitude <code>49.2847</code>.</p> <note> <p> <code>BiasPosition</code> and <code>FilterBBox</code> are mutually exclusive. Specifying both options results in an error. </p> </note>',
        max_length=2,
        min_length=2,
    )
    FilterBBox: Optional[List[Double]] = Field(
        None,
        description='<p>An optional parameter that limits the search results by returning only places that are within the provided bounding box.</p> <p> If provided, this parameter must contain a total of four consecutive numbers in two pairs. The first pair of numbers represents the X and Y coordinates (longitude and latitude, respectively) of the southwest corner of the bounding box; the second pair of numbers represents the X and Y coordinates (longitude and latitude, respectively) of the northeast corner of the bounding box.</p> <p>For example, <code>[-12.7935, -37.4835, -12.0684, -36.9542]</code> represents a bounding box where the southwest corner has longitude <code>-12.7935</code> and latitude <code>-37.4835</code>, and the northeast corner has longitude <code>-12.0684</code> and latitude <code>-36.9542</code>.</p> <note> <p> <code>FilterBBox</code> and <code>BiasPosition</code> are mutually exclusive. Specifying both options results in an error. </p> </note>',
        max_length=4,
        min_length=4,
    )
    FilterCountries: Optional[List[CountryCode]] = Field(
        None,
        description='<p>An optional parameter that limits the search results by returning only places that are in a specified list of countries.</p> <ul> <li> <p>Valid values include <a href="https://www.iso.org/iso-3166-country-codes.html">ISO 3166</a> 3-digit country codes. For example, Australia uses three upper-case characters: <code>AUS</code>.</p> </li> </ul>',
        max_length=100,
        min_length=1,
    )
    Language: Optional[constr(min_length=2, max_length=35)] = Field(
        None,
        description='<p>The preferred language used to return results. The value must be a valid <a href="https://tools.ietf.org/search/bcp47">BCP 47</a> language tag, for example, <code>en</code> for English.</p> <p>This setting affects the languages used in the results, but not the results themselves. If no language is specified, or not supported for a particular result, the partner automatically chooses a language for the result.</p> <p>For an example, we\'ll use the Greek language. You search for <code>Athens, Greece</code>, with the <code>language</code> parameter set to <code>en</code>. The result found will most likely be returned as <code>Athens</code>.</p> <p>If you set the <code>language</code> parameter to <code>el</code>, for Greek, then the result found will more likely be returned as <code>Αθήνα</code>.</p> <p>If the data provider does not have a value for Greek, the result will be in a language that the provider does support.</p>',
    )
    MaxResults: Optional[conint(ge=1, le=50)] = Field(
        None,
        description='<p>An optional parameter. The maximum number of results returned per request. </p> <p>The default: <code>50</code> </p>',
    )
    Text: SecretStr = Field(
        ...,
        description='The address, name, city, or region to be used in the search in free-form text format. For example, <code>123 Any Street</code>.',
    )


class PlacesV0ListIndexesPostRequest(BaseModel):
    MaxResults: Optional[conint(ge=1, le=100)] = Field(
        None,
        description='<p>An optional limit for the maximum number of results returned in a single call.</p> <p>Default value: <code>100</code> </p>',
    )
    NextToken: Optional[constr(min_length=1, max_length=2000)] = Field(
        None,
        description='<p>The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page.</p> <p>Default value: <code>null</code> </p>',
    )


class RoutesV0CalculatorsPostRequest(BaseModel):
    CalculatorName: constr(pattern=r'^[-._\w]+$', min_length=1, max_length=100) = Field(
        ...,
        description='<p>The name of the route calculator resource. </p> <p>Requirements:</p> <ul> <li> <p>Can use alphanumeric characters (A–Z, a–z, 0–9) , hyphens (-), periods (.), and underscores (_).</p> </li> <li> <p>Must be a unique Route calculator resource name.</p> </li> <li> <p>No spaces allowed. For example, <code>ExampleRouteCalculator</code>.</p> </li> </ul>',
    )
    DataSource: str = Field(
        ...,
        description='<p>Specifies the data provider of traffic and road network data.</p> <note> <p>This field is case-sensitive. Enter the valid values as shown. For example, entering <code>HERE</code> returns an error.</p> </note> <p>Valid values include:</p> <ul> <li> <p> <code>Esri</code> – For additional information about <a href="https://docs.aws.amazon.com/location/latest/developerguide/esri.html">Esri</a>\'s coverage in your region of interest, see <a href="https://doc.arcgis.com/en/arcgis-online/reference/network-coverage.htm">Esri details on street networks and traffic coverage</a>.</p> <p>Route calculators that use Esri as a data source only calculate routes that are shorter than 400 km.</p> </li> <li> <p> <code>Grab</code> – Grab provides routing functionality for Southeast Asia. For additional information about <a href="https://docs.aws.amazon.com/location/latest/developerguide/grab.html">GrabMaps</a>\' coverage, see <a href="https://docs.aws.amazon.com/location/latest/developerguide/grab.html#grab-coverage-area">GrabMaps countries and areas covered</a>.</p> </li> <li> <p> <code>Here</code> – For additional information about <a href="https://docs.aws.amazon.com/location/latest/developerguide/HERE.html">HERE Technologies</a>\' coverage in your region of interest, see <a href="https://developer.here.com/documentation/routing-api/dev_guide/topics/coverage/car-routing.html">HERE car routing coverage</a> and <a href="https://developer.here.com/documentation/routing-api/dev_guide/topics/coverage/truck-routing.html">HERE truck routing coverage</a>.</p> </li> </ul> <p>For additional information , see <a href="https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html">Data providers</a> on the <i>Amazon Location Service Developer Guide</i>.</p>',
    )
    Description: Optional[constr(min_length=0, max_length=1000)] = Field(
        None, description='The optional description for the route calculator resource.'
    )
    PricingPlan_1: Optional[PricingPlan] = Field(
        None,
        alias='PricingPlan',
        description='No longer used. If included, the only allowed value is <code>RequestBasedUsage</code>.',
    )
    Tags: Optional[Dict[str, TagValue]] = Field(
        None,
        description='<p>Applies one or more tags to the route calculator resource. A tag is a key-value pair helps manage, identify, search, and filter your resources by labelling them.</p> <ul> <li> <p>For example: { <code>"tag1" : "value1"</code>, <code>"tag2" : "value2"</code>}</p> </li> </ul> <p>Format: <code>"key" : "value"</code> </p> <p>Restrictions:</p> <ul> <li> <p>Maximum 50 tags per resource</p> </li> <li> <p>Each resource tag must be unique with a maximum of one value.</p> </li> <li> <p>Maximum key length: 128 Unicode characters in UTF-8</p> </li> <li> <p>Maximum value length: 256 Unicode characters in UTF-8</p> </li> <li> <p>Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @. </p> </li> <li> <p>Cannot use "aws:" as a prefix for a key.</p> </li> </ul>',
    )


class RoutesV0CalculatorsCalculatorNamePatchRequest(BaseModel):
    Description: Optional[constr(min_length=0, max_length=1000)] = Field(
        None, description='Updates the description for the route calculator resource.'
    )
    PricingPlan_1: Optional[PricingPlan] = Field(
        None,
        alias='PricingPlan',
        description='No longer used. If included, the only allowed value is <code>RequestBasedUsage</code>.',
    )


class CarModeOptions(BaseModel):
    AvoidFerries: Optional[Boolean] = None
    AvoidTolls: Optional[Boolean] = None


class RoutesV0ListCalculatorsPostRequest(BaseModel):
    MaxResults: Optional[conint(ge=1, le=100)] = Field(
        None,
        description='<p>An optional maximum number of results returned in a single call.</p> <p>Default Value: <code>100</code> </p>',
    )
    NextToken: Optional[constr(min_length=1, max_length=2000)] = Field(
        None,
        description='<p>The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page.</p> <p>Default Value: <code>null</code> </p>',
    )


class TagsResourceArnPostRequest(BaseModel):
    Tags: Dict[str, TagValue] = Field(
        ...,
        description='<p>Applies one or more tags to specific resource. A tag is a key-value pair that helps you manage, identify, search, and filter your resources.</p> <p>Format: <code>"key" : "value"</code> </p> <p>Restrictions:</p> <ul> <li> <p>Maximum 50 tags per resource.</p> </li> <li> <p>Each tag key must be unique and must have exactly one associated value.</p> </li> <li> <p>Maximum key length: 128 Unicode characters in UTF-8.</p> </li> <li> <p>Maximum value length: 256 Unicode characters in UTF-8.</p> </li> <li> <p>Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @</p> </li> <li> <p>Cannot use "aws:" as a prefix for a key.</p> </li> </ul>',
    )


class TrackingV0ListTrackersPostRequest(BaseModel):
    MaxResults: Optional[conint(ge=1, le=100)] = Field(
        None,
        description='<p>An optional limit for the number of resources returned in a single call. </p> <p>Default value: <code>100</code> </p>',
    )
    NextToken: Optional[constr(min_length=1, max_length=2000)] = Field(
        None,
        description='<p>The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. </p> <p>Default value: <code>null</code> </p>',
    )


class TrackingV0TrackersPostRequest(BaseModel):
    Description: Optional[constr(min_length=0, max_length=1000)] = Field(
        None, description='An optional description for the tracker resource.'
    )
    KmsKeyId: Optional[constr(min_length=1, max_length=2048)] = Field(
        None,
        description='A key identifier for an <a href="https://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html">Amazon Web Services KMS customer managed key</a>. Enter a key ID, key ARN, alias name, or alias ARN.',
    )
    PositionFiltering_1: Optional[PositionFiltering] = Field(
        None,
        alias='PositionFiltering',
        description='<p>Specifies the position filtering for the tracker resource.</p> <p>Valid values:</p> <ul> <li> <p> <code>TimeBased</code> - Location updates are evaluated against linked geofence collections, but not every location update is stored. If your update frequency is more often than 30 seconds, only one update per 30 seconds is stored for each unique device ID. </p> </li> <li> <p> <code>DistanceBased</code> - If the device has moved less than 30 m (98.4 ft), location updates are ignored. Location updates within this area are neither evaluated against linked geofence collections, nor stored. This helps control costs by reducing the number of geofence evaluations and historical device positions to paginate through. Distance-based filtering can also reduce the effects of GPS noise when displaying device trajectories on a map. </p> </li> <li> <p> <code>AccuracyBased</code> - If the device has moved less than the measured accuracy, location updates are ignored. For example, if two consecutive updates from a device have a horizontal accuracy of 5 m and 10 m, the second update is ignored if the device has moved less than 15 m. Ignored location updates are neither evaluated against linked geofence collections, nor stored. This can reduce the effects of GPS noise when displaying device trajectories on a map, and can help control your costs by reducing the number of geofence evaluations. </p> </li> </ul> <p>This field is optional. If not specified, the default value is <code>TimeBased</code>.</p>',
    )
    PricingPlan_1: Optional[PricingPlan] = Field(
        None,
        alias='PricingPlan',
        description='No longer used. If included, the only allowed value is <code>RequestBasedUsage</code>.',
    )
    PricingPlanDataSource: Optional[str] = Field(
        None, description='This parameter is no longer used.'
    )
    Tags: Optional[Dict[str, TagValue]] = Field(
        None,
        description='<p>Applies one or more tags to the tracker resource. A tag is a key-value pair helps manage, identify, search, and filter your resources by labelling them.</p> <p>Format: <code>"key" : "value"</code> </p> <p>Restrictions:</p> <ul> <li> <p>Maximum 50 tags per resource</p> </li> <li> <p>Each resource tag must be unique with a maximum of one value.</p> </li> <li> <p>Maximum key length: 128 Unicode characters in UTF-8</p> </li> <li> <p>Maximum value length: 256 Unicode characters in UTF-8</p> </li> <li> <p>Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @. </p> </li> <li> <p>Cannot use "aws:" as a prefix for a key.</p> </li> </ul>',
    )
    TrackerName: constr(pattern=r'^[-._\w]+$', min_length=1, max_length=100) = Field(
        ...,
        description='<p>The name for the tracker resource.</p> <p>Requirements:</p> <ul> <li> <p>Contain only alphanumeric characters (A-Z, a-z, 0-9) , hyphens (-), periods (.), and underscores (_).</p> </li> <li> <p>Must be a unique tracker resource name.</p> </li> <li> <p>No spaces allowed. For example, <code>ExampleTracker</code>.</p> </li> </ul>',
    )


class TrackingV0TrackersTrackerNamePatchRequest(BaseModel):
    Description: Optional[constr(min_length=0, max_length=1000)] = Field(
        None, description='Updates the description for the tracker resource.'
    )
    PositionFiltering_1: Optional[PositionFiltering] = Field(
        None,
        alias='PositionFiltering',
        description='<p>Updates the position filtering for the tracker resource.</p> <p>Valid values:</p> <ul> <li> <p> <code>TimeBased</code> - Location updates are evaluated against linked geofence collections, but not every location update is stored. If your update frequency is more often than 30 seconds, only one update per 30 seconds is stored for each unique device ID. </p> </li> <li> <p> <code>DistanceBased</code> - If the device has moved less than 30 m (98.4 ft), location updates are ignored. Location updates within this distance are neither evaluated against linked geofence collections, nor stored. This helps control costs by reducing the number of geofence evaluations and historical device positions to paginate through. Distance-based filtering can also reduce the effects of GPS noise when displaying device trajectories on a map. </p> </li> <li> <p> <code>AccuracyBased</code> - If the device has moved less than the measured accuracy, location updates are ignored. For example, if two consecutive updates from a device have a horizontal accuracy of 5 m and 10 m, the second update is ignored if the device has moved less than 15 m. Ignored location updates are neither evaluated against linked geofence collections, nor stored. This helps educe the effects of GPS noise when displaying device trajectories on a map, and can help control costs by reducing the number of geofence evaluations. </p> </li> </ul>',
    )
    PricingPlan_1: Optional[PricingPlan] = Field(
        None,
        alias='PricingPlan',
        description='No longer used. If included, the only allowed value is <code>RequestBasedUsage</code>.',
    )
    PricingPlanDataSource: Optional[str] = Field(
        None, description='This parameter is no longer used.'
    )


class TrackingV0TrackersTrackerNameConsumersPostRequest(BaseModel):
    ConsumerArn: constr(
        pattern=r'^arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:([^/].*)?$',
        min_length=0,
        max_length=1600,
    ) = Field(
        ...,
        description='<p>The Amazon Resource Name (ARN) for the geofence collection to be associated to tracker resource. Used when you need to specify a resource across all Amazon Web Services.</p> <ul> <li> <p>Format example: <code>arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollectionConsumer</code> </p> </li> </ul>',
    )


class TrackingV0TrackersTrackerNameDeletePositionsPostRequest(BaseModel):
    DeviceIds: List[Id] = Field(
        ...,
        description='<p>Devices whose position history you want to delete.</p> <ul> <li> <p>For example, for two devices: <code>“DeviceIds” : [DeviceId1,DeviceId2]</code> </p> </li> </ul>',
        max_length=100,
        min_length=1,
    )


class TrackingV0TrackersTrackerNameDevicesDeviceIdListPositionsPostRequest(BaseModel):
    EndTimeExclusive: Optional[datetime] = Field(
        None,
        description='<p>Specify the end time for the position history in <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601</a> format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>. By default, the value will be the time that the request is made.</p> <p>Requirement:</p> <ul> <li> <p>The time specified for <code>EndTimeExclusive</code> must be after the time for <code>StartTimeInclusive</code>.</p> </li> </ul>',
    )
    MaxResults: Optional[conint(ge=1, le=100)] = Field(
        None,
        description='<p>An optional limit for the number of device positions returned in a single call.</p> <p>Default value: <code>100</code> </p>',
    )
    NextToken: Optional[constr(min_length=1, max_length=2000)] = Field(
        None,
        description='<p>The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. </p> <p>Default value: <code>null</code> </p>',
    )
    StartTimeInclusive: Optional[datetime] = Field(
        None,
        description='<p>Specify the start time for the position history in <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601</a> format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>. By default, the value will be 24 hours prior to the time that the request is made.</p> <p>Requirement:</p> <ul> <li> <p>The time specified for <code>StartTimeInclusive</code> must be before <code>EndTimeExclusive</code>.</p> </li> </ul>',
    )


class TrackingV0TrackersTrackerNameGetPositionsPostRequest(BaseModel):
    DeviceIds: List[Id] = Field(
        ...,
        description='<p>Devices whose position you want to retrieve.</p> <ul> <li> <p>For example, for two devices: <code>device-ids=DeviceId1&amp;device-ids=DeviceId2</code> </p> </li> </ul>',
        max_length=10,
        min_length=1,
    )


class TrackingV0TrackersTrackerNameListConsumersPostRequest(BaseModel):
    MaxResults: Optional[conint(ge=1, le=100)] = Field(
        None,
        description='<p>An optional limit for the number of resources returned in a single call. </p> <p>Default value: <code>100</code> </p>',
    )
    NextToken: Optional[constr(min_length=1, max_length=2000)] = Field(
        None,
        description='<p>The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page. </p> <p>Default value: <code>null</code> </p>',
    )


class TrackingV0TrackersTrackerNameListPositionsPostRequest(BaseModel):
    MaxResults: Optional[conint(ge=1, le=100)] = Field(
        None,
        description='<p>An optional limit for the number of entries returned in a single call.</p> <p>Default value: <code>100</code> </p>',
    )
    NextToken: Optional[constr(min_length=1, max_length=2000)] = Field(
        None,
        description='<p>The pagination token specifying which page of results to return in the response. If no token is provided, the default page is the first page.</p> <p>Default value: <code>null</code> </p>',
    )


class ApiKeyFilter(BaseModel):
    KeyStatus: Optional[Status] = None


class ApiKeyRestrictionsAllowReferersList(RootModel[List[RefererPattern]]):
    root: List[RefererPattern] = Field(..., max_length=5, min_length=1)


class ApiKeyRestrictionsAllowResourcesList(RootModel[List[GeoArn]]):
    root: List[GeoArn] = Field(..., max_length=5, min_length=1)


class BatchDeleteDevicePositionHistoryRequestDeviceIdsList(RootModel[List[Id]]):
    root: List[Id] = Field(..., max_length=100, min_length=1)


class BatchDeleteGeofenceRequestGeofenceIdsList(RootModel[List[Id]]):
    root: List[Id] = Field(..., max_length=10, min_length=1)


class BatchGetDevicePositionRequestDeviceIdsList(RootModel[List[Id]]):
    root: List[Id] = Field(..., max_length=10, min_length=1)


class BatchItemError(BaseModel):
    Code: Optional[BatchItemErrorCode] = None
    Message: Optional[String] = None


class BatchPutGeofenceError(BaseModel):
    Error: BatchItemError
    GeofenceId: Id


class BatchPutGeofenceErrorList(RootModel[List[BatchPutGeofenceError]]):
    root: List[BatchPutGeofenceError]


class BatchPutGeofenceSuccess(BaseModel):
    CreateTime: Timestamp
    GeofenceId: Id
    UpdateTime: Timestamp


class BatchPutGeofenceSuccessList(RootModel[List[BatchPutGeofenceSuccess]]):
    root: List[BatchPutGeofenceSuccess]


class BatchUpdateDevicePositionError(BaseModel):
    DeviceId: Id
    Error: BatchItemError
    SampleTime: Timestamp


class BatchUpdateDevicePositionErrorList(
    RootModel[List[BatchUpdateDevicePositionError]]
):
    root: List[BatchUpdateDevicePositionError]


class BatchUpdateDevicePositionResponse(BaseModel):
    Errors: BatchUpdateDevicePositionErrorList


class BoundingBox(RootModel[List[Double]]):
    root: List[Double] = Field(..., max_length=4, min_length=4)


class CalculateRouteMatrixRequestDeparturePositionsList(RootModel[List[Position]]):
    root: List[Position] = Field(..., max_length=350, min_length=1)


class CalculateRouteMatrixRequestDestinationPositionsList(RootModel[List[Position]]):
    root: List[Position] = Field(..., max_length=350, min_length=1)


class CalculateRouteMatrixResponseSnappedDeparturePositionsList(
    RootModel[List[Position]]
):
    root: List[Position] = Field(..., max_length=350, min_length=1)


class CalculateRouteMatrixResponseSnappedDestinationPositionsList(
    RootModel[List[Position]]
):
    root: List[Position] = Field(..., max_length=350, min_length=1)


class CalculateRouteMatrixSummary(BaseModel):
    DataSource: String
    DistanceUnit_1: DistanceUnit = Field(..., alias='DistanceUnit')
    ErrorCount: CalculateRouteMatrixSummaryErrorCountInteger
    RouteCount: CalculateRouteMatrixSummaryRouteCountInteger


class CalculateRouteRequestWaypointPositionsList(RootModel[List[Position]]):
    root: List[Position] = Field(..., max_length=23, min_length=0)


class CalculateRouteSummary(BaseModel):
    DataSource: String
    Distance: CalculateRouteSummaryDistanceDouble
    DistanceUnit_1: DistanceUnit = Field(..., alias='DistanceUnit')
    DurationSeconds: CalculateRouteSummaryDurationSecondsDouble
    RouteBBox: BoundingBox


class Circle(BaseModel):
    Center: Position
    Radius: Double


class CreateGeofenceCollectionResponse(BaseModel):
    CollectionArn: Arn
    CollectionName: ResourceName
    CreateTime: Timestamp


class CreateKeyResponse(BaseModel):
    CreateTime: Timestamp
    Key: ApiKey
    KeyArn: Arn
    KeyName: ResourceName


class CreateMapResponse(BaseModel):
    CreateTime: Timestamp
    MapArn: GeoArn
    MapName: ResourceName


class CreatePlaceIndexResponse(BaseModel):
    CreateTime: Timestamp
    IndexArn: Arn
    IndexName: ResourceName


class CreateRouteCalculatorResponse(BaseModel):
    CalculatorArn: Arn
    CalculatorName: ResourceName
    CreateTime: Timestamp


class CreateTrackerResponse(BaseModel):
    CreateTime: Timestamp
    TrackerArn: Arn
    TrackerName: ResourceName


class GetDevicePositionHistoryRequest(BaseModel):
    EndTimeExclusive: Optional[Timestamp] = None
    MaxResults: Optional[GetDevicePositionHistoryRequestMaxResultsInteger] = None
    NextToken: Optional[Token] = None
    StartTimeInclusive: Optional[Timestamp] = None


class LineString(RootModel[List[Position]]):
    root: List[Position] = Field(..., min_length=2)


class LinearRing(RootModel[List[Position]]):
    root: List[Position] = Field(..., min_length=4)


class LinearRings(RootModel[List[LinearRing]]):
    root: List[LinearRing] = Field(..., min_length=1)


class ListDevicePositionsRequest(BaseModel):
    MaxResults: Optional[ListDevicePositionsRequestMaxResultsInteger] = None
    NextToken: Optional[Token] = None


class ListGeofenceCollectionsRequest(BaseModel):
    MaxResults: Optional[ListGeofenceCollectionsRequestMaxResultsInteger] = None
    NextToken: Optional[Token] = None


class ListGeofenceCollectionsResponseEntry(BaseModel):
    CollectionName: ResourceName
    CreateTime: Timestamp
    Description: ResourceDescription
    PricingPlan_1: Optional[PricingPlan] = Field(None, alias='PricingPlan')
    PricingPlanDataSource: Optional[String] = None
    UpdateTime: Timestamp


class ListGeofenceCollectionsResponseEntryList(
    RootModel[List[ListGeofenceCollectionsResponseEntry]]
):
    root: List[ListGeofenceCollectionsResponseEntry]


class ListGeofencesRequest(BaseModel):
    MaxResults: Optional[ListGeofencesRequestMaxResultsInteger] = None
    NextToken: Optional[Token] = None


class ListKeysRequest(BaseModel):
    Filter: Optional[ApiKeyFilter] = None
    MaxResults: Optional[ListKeysRequestMaxResultsInteger] = None
    NextToken: Optional[Token] = None


class ListMapsRequest(BaseModel):
    MaxResults: Optional[ListMapsRequestMaxResultsInteger] = None
    NextToken: Optional[Token] = None


class ListMapsResponseEntry(BaseModel):
    CreateTime: Timestamp
    DataSource: String
    Description: ResourceDescription
    MapName: ResourceName
    PricingPlan_1: Optional[PricingPlan] = Field(None, alias='PricingPlan')
    UpdateTime: Timestamp


class ListMapsResponseEntryList(RootModel[List[ListMapsResponseEntry]]):
    root: List[ListMapsResponseEntry]


class ListPlaceIndexesRequest(BaseModel):
    MaxResults: Optional[ListPlaceIndexesRequestMaxResultsInteger] = None
    NextToken: Optional[Token] = None


class ListPlaceIndexesResponseEntry(BaseModel):
    CreateTime: Timestamp
    DataSource: String
    Description: ResourceDescription
    IndexName: ResourceName
    PricingPlan_1: Optional[PricingPlan] = Field(None, alias='PricingPlan')
    UpdateTime: Timestamp


class ListPlaceIndexesResponseEntryList(RootModel[List[ListPlaceIndexesResponseEntry]]):
    root: List[ListPlaceIndexesResponseEntry]


class ListRouteCalculatorsRequest(BaseModel):
    MaxResults: Optional[ListRouteCalculatorsRequestMaxResultsInteger] = None
    NextToken: Optional[Token] = None


class ListRouteCalculatorsResponseEntry(BaseModel):
    CalculatorName: ResourceName
    CreateTime: Timestamp
    DataSource: String
    Description: ResourceDescription
    PricingPlan_1: Optional[PricingPlan] = Field(None, alias='PricingPlan')
    UpdateTime: Timestamp


class ListRouteCalculatorsResponseEntryList(
    RootModel[List[ListRouteCalculatorsResponseEntry]]
):
    root: List[ListRouteCalculatorsResponseEntry]


class ListTrackerConsumersRequest(BaseModel):
    MaxResults: Optional[ListTrackerConsumersRequestMaxResultsInteger] = None
    NextToken: Optional[Token] = None


class ListTrackerConsumersResponse(BaseModel):
    ConsumerArns: ArnList
    NextToken: Optional[Token] = None


class ListTrackersRequest(BaseModel):
    MaxResults: Optional[ListTrackersRequestMaxResultsInteger] = None
    NextToken: Optional[Token] = None


class ListTrackersResponseEntry(BaseModel):
    CreateTime: Timestamp
    Description: ResourceDescription
    PricingPlan_1: Optional[PricingPlan] = Field(None, alias='PricingPlan')
    PricingPlanDataSource: Optional[String] = None
    TrackerName: ResourceName
    UpdateTime: Timestamp


class ListTrackersResponseEntryList(RootModel[List[ListTrackersResponseEntry]]):
    root: List[ListTrackersResponseEntry]


class MapConfiguration(BaseModel):
    Style: MapStyle


class PlaceGeometry(BaseModel):
    Point: Optional[Position] = None


class PositionalAccuracy(BaseModel):
    Horizontal: PositionalAccuracyHorizontalDouble


class PropertyMap(RootModel[Optional[Dict[str, PropertyMapValueString]]]):
    root: Optional[Dict[str, PropertyMapValueString]] = None


class PutGeofenceResponse(BaseModel):
    CreateTime: Timestamp
    GeofenceId: Id
    UpdateTime: Timestamp


class RouteMatrixEntryError(BaseModel):
    Code: RouteMatrixErrorCode
    Message: Optional[String] = None


class SearchForSuggestionsResult(BaseModel):
    PlaceId_1: Optional[PlaceId] = Field(None, alias='PlaceId')
    Text: String


class SearchForSuggestionsResultList(RootModel[List[SearchForSuggestionsResult]]):
    root: List[SearchForSuggestionsResult]


class SearchPlaceIndexForPositionSummary(BaseModel):
    DataSource: String
    Language: Optional[LanguageTag] = None
    MaxResults: Optional[PlaceIndexSearchResultLimit] = None
    Position_1: Position = Field(..., alias='Position')


class SearchPlaceIndexForSuggestionsRequest(BaseModel):
    BiasPosition: Optional[Position] = None
    FilterBBox: Optional[BoundingBox] = None
    FilterCountries: Optional[CountryCodeList] = None
    Language: Optional[LanguageTag] = None
    MaxResults: Optional[SearchPlaceIndexForSuggestionsRequestMaxResultsInteger] = None
    Text: SearchPlaceIndexForSuggestionsRequestTextString


class SearchPlaceIndexForSuggestionsSummary(BaseModel):
    BiasPosition: Optional[Position] = None
    DataSource: String
    FilterBBox: Optional[BoundingBox] = None
    FilterCountries: Optional[CountryCodeList] = None
    Language: Optional[LanguageTag] = None
    MaxResults: Optional[Integer] = None
    Text: SensitiveString


class SearchPlaceIndexForTextRequest(BaseModel):
    BiasPosition: Optional[Position] = None
    FilterBBox: Optional[BoundingBox] = None
    FilterCountries: Optional[CountryCodeList] = None
    Language: Optional[LanguageTag] = None
    MaxResults: Optional[PlaceIndexSearchResultLimit] = None
    Text: SearchPlaceIndexForTextRequestTextString


class SearchPlaceIndexForTextSummary(BaseModel):
    BiasPosition: Optional[Position] = None
    DataSource: String
    FilterBBox: Optional[BoundingBox] = None
    FilterCountries: Optional[CountryCodeList] = None
    Language: Optional[LanguageTag] = None
    MaxResults: Optional[PlaceIndexSearchResultLimit] = None
    ResultBBox: Optional[BoundingBox] = None
    Text: SensitiveString


class Step(BaseModel):
    Distance: StepDistanceDouble
    DurationSeconds: StepDurationSecondsDouble
    EndPosition: Position
    GeometryOffset: Optional[StepGeometryOffsetInteger] = None
    StartPosition: Position


class StepList(RootModel[List[Step]]):
    root: List[Step]


class TagMap(RootModel[Optional[Dict[str, TagValue]]]):
    root: Optional[Dict[str, TagValue]] = None


class TagResourceRequest(BaseModel):
    Tags: TagMap


class TruckDimensions(BaseModel):
    Height: Optional[TruckDimensionsHeightDouble] = None
    Length: Optional[TruckDimensionsLengthDouble] = None
    Unit: Optional[DimensionUnit] = None
    Width: Optional[TruckDimensionsWidthDouble] = None


class TruckWeight(BaseModel):
    Total: Optional[TruckWeightTotalDouble] = None
    Unit: Optional[VehicleWeightUnit] = None


class UpdatePlaceIndexRequest(BaseModel):
    DataSourceConfiguration_1: Optional[DataSourceConfiguration] = Field(
        None, alias='DataSourceConfiguration'
    )
    Description: Optional[ResourceDescription] = None
    PricingPlan_1: Optional[PricingPlan] = Field(None, alias='PricingPlan')


class Geometry(BaseModel):
    Circle_1: Optional[Circle] = Field(None, alias='Circle')
    Polygon: Optional[LinearRings] = None


class GeofencingV0CollectionsCollectionNameGeofencesGeofenceIdPutRequest(BaseModel):
    Geometry_1: Geometry = Field(
        ...,
        alias='Geometry',
        description="<p>Contains the geofence geometry details.</p> <p>A geofence geometry is made up of either a polygon or a circle. Can be either a polygon or a circle. Including both will return a validation error.</p> <note> <p>Amazon Location doesn't currently support polygons with holes, multipolygons, polygons that are wound clockwise, or that cross the antimeridian. </p> </note>",
    )


class Restrictions(BaseModel):
    AllowActions: Optional[ApiKeyRestrictionsAllowActionsList] = None
    AllowReferers: Optional[ApiKeyRestrictionsAllowReferersList] = None
    AllowResources: Optional[ApiKeyRestrictionsAllowResourcesList] = None


class MetadataV0KeysPostRequest(BaseModel):
    Description: Optional[constr(min_length=0, max_length=1000)] = Field(
        None, description='An optional description for the API key resource.'
    )
    ExpireTime: Optional[datetime] = Field(
        None,
        description='The optional timestamp for when the API key resource will expire in <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601</a> format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>. One of <code>NoExpiry</code> or <code>ExpireTime</code> must be set.',
    )
    KeyName: constr(pattern=r'^[-._\w]+$', min_length=1, max_length=100) = Field(
        ...,
        description='<p>A custom name for the API key resource.</p> <p>Requirements:</p> <ul> <li> <p>Contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods (.), and underscores (_). </p> </li> <li> <p>Must be a unique API key name.</p> </li> <li> <p>No spaces allowed. For example, <code>ExampleAPIKey</code>.</p> </li> </ul>',
    )
    NoExpiry: Optional[bool] = Field(
        None,
        description='Optionally set to <code>true</code> to set no expiration time for the API key. One of <code>NoExpiry</code> or <code>ExpireTime</code> must be set.',
    )
    Restrictions_1: Restrictions = Field(
        ...,
        alias='Restrictions',
        description='API Restrictions on the allowed actions, resources, and referers for an API key resource.',
    )
    Tags: Optional[Dict[str, TagValue]] = Field(
        None,
        description='<p>Applies one or more tags to the map resource. A tag is a key-value pair that helps manage, identify, search, and filter your resources by labelling them.</p> <p>Format: <code>"key" : "value"</code> </p> <p>Restrictions:</p> <ul> <li> <p>Maximum 50 tags per resource</p> </li> <li> <p>Each resource tag must be unique with a maximum of one value.</p> </li> <li> <p>Maximum key length: 128 Unicode characters in UTF-8</p> </li> <li> <p>Maximum value length: 256 Unicode characters in UTF-8</p> </li> <li> <p>Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : / @. </p> </li> <li> <p>Cannot use "aws:" as a prefix for a key.</p> </li> </ul>',
    )


class MetadataV0KeysKeyNamePatchRequest(BaseModel):
    Description: Optional[constr(min_length=0, max_length=1000)] = Field(
        None, description='Updates the description for the API key resource.'
    )
    ExpireTime: Optional[datetime] = Field(
        None,
        description='Updates the timestamp for when the API key resource will expire in <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601</a> format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>. ',
    )
    ForceUpdate: Optional[bool] = Field(
        None,
        description='<p>The boolean flag to be included for updating <code>ExpireTime</code> or <code>Restrictions</code> details.</p> <p>Must be set to <code>true</code> to update an API key resource that has been used in the past 7 days.</p> <p> <code>False</code> if force update is not preferred</p> <p>Default value: <code>False</code> </p>',
    )
    NoExpiry: Optional[bool] = Field(
        None,
        description='Whether the API key should expire. Set to <code>true</code> to set the API key to have no expiration time.',
    )
    Restrictions_1: Optional[Restrictions] = Field(
        None,
        alias='Restrictions',
        description='API Restrictions on the allowed actions, resources, and referers for an API key resource.',
    )


class TruckModeOptions(BaseModel):
    AvoidFerries: Optional[Boolean] = None
    AvoidTolls: Optional[Boolean] = None
    Dimensions: Optional[TruckDimensions] = None
    Weight: Optional[TruckWeight] = None


class RoutesV0CalculatorsCalculatorNameCalculateRoutePostRequest(BaseModel):
    CarModeOptions_1: Optional[CarModeOptions] = Field(
        None,
        alias='CarModeOptions',
        description='Contains details about additional route preferences for requests that specify <code>TravelMode</code> as <code>Car</code>.',
    )
    DepartNow: Optional[bool] = Field(
        None,
        description='<p>Sets the time of departure as the current time. Uses the current time to calculate a route. Otherwise, the best time of day to travel with the best traffic conditions is used to calculate the route.</p> <p>Default Value: <code>false</code> </p> <p>Valid Values: <code>false</code> | <code>true</code> </p>',
    )
    DeparturePosition: List[Double] = Field(
        ...,
        description='<p>The start position for the route. Defined in <a href="https://earth-info.nga.mil/index.php?dir=wgs84&amp;action=wgs84">World Geodetic System (WGS 84)</a> format: <code>[longitude, latitude]</code>.</p> <ul> <li> <p>For example, <code>[-123.115, 49.285]</code> </p> </li> </ul> <note> <p>If you specify a departure that\'s not located on a road, Amazon Location <a href="https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html">moves the position to the nearest road</a>. If Esri is the provider for your route calculator, specifying a route that is longer than 400 km returns a <code>400 RoutesValidationException</code> error.</p> </note> <p>Valid Values: <code>[-180 to 180,-90 to 90]</code> </p>',
        max_length=2,
        min_length=2,
    )
    DepartureTime: Optional[datetime] = Field(
        None,
        description='<p>Specifies the desired time of departure. Uses the given time to calculate the route. Otherwise, the best time of day to travel with the best traffic conditions is used to calculate the route.</p> <note> <p>Setting a departure time in the past returns a <code>400 ValidationException</code> error.</p> </note> <ul> <li> <p>In <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601</a> format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>. For example, <code>2020–07-2T12:15:20.000Z+01:00</code> </p> </li> </ul>',
    )
    DestinationPosition: List[Double] = Field(
        ...,
        description='<p>The finish position for the route. Defined in <a href="https://earth-info.nga.mil/index.php?dir=wgs84&amp;action=wgs84">World Geodetic System (WGS 84)</a> format: <code>[longitude, latitude]</code>.</p> <ul> <li> <p> For example, <code>[-122.339, 47.615]</code> </p> </li> </ul> <note> <p>If you specify a destination that\'s not located on a road, Amazon Location <a href="https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html">moves the position to the nearest road</a>. </p> </note> <p>Valid Values: <code>[-180 to 180,-90 to 90]</code> </p>',
        max_length=2,
        min_length=2,
    )
    DistanceUnit_1: Optional[DistanceUnit] = Field(
        None,
        alias='DistanceUnit',
        description='<p>Set the unit system to specify the distance.</p> <p>Default Value: <code>Kilometers</code> </p>',
    )
    IncludeLegGeometry: Optional[bool] = Field(
        None,
        description='<p>Set to include the geometry details in the result for each path between a pair of positions.</p> <p>Default Value: <code>false</code> </p> <p>Valid Values: <code>false</code> | <code>true</code> </p>',
    )
    TravelMode_1: Optional[TravelMode] = Field(
        None,
        alias='TravelMode',
        description='<p>Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility. You can choose <code>Car</code>, <code>Truck</code>, <code>Walking</code>, <code>Bicycle</code> or <code>Motorcycle</code> as options for the <code>TravelMode</code>.</p> <note> <p> <code>Bicycle</code> and <code>Motorcycle</code> are only valid when using Grab as a data provider, and only within Southeast Asia.</p> <p> <code>Truck</code> is not available for Grab.</p> <p>For more details on the using Grab for routing, including areas of coverage, see <a href="https://docs.aws.amazon.com/location/latest/developerguide/grab.html">GrabMaps</a> in the <i>Amazon Location Service Developer Guide</i>.</p> </note> <p>The <code>TravelMode</code> you specify also determines how you specify route preferences: </p> <ul> <li> <p>If traveling by <code>Car</code> use the <code>CarModeOptions</code> parameter.</p> </li> <li> <p>If traveling by <code>Truck</code> use the <code>TruckModeOptions</code> parameter.</p> </li> </ul> <p>Default Value: <code>Car</code> </p>',
    )
    TruckModeOptions_1: Optional[TruckModeOptions] = Field(
        None,
        alias='TruckModeOptions',
        description='Contains details about additional route preferences for requests that specify <code>TravelMode</code> as <code>Truck</code>.',
    )
    WaypointPositions: Optional[List[Position]] = Field(
        None,
        description='<p>Specifies an ordered list of up to 23 intermediate positions to include along a route between the departure position and destination position. </p> <ul> <li> <p>For example, from the <code>DeparturePosition</code> <code>[-123.115, 49.285]</code>, the route follows the order that the waypoint positions are given <code>[[-122.757, 49.0021],[-122.349, 47.620]]</code> </p> </li> </ul> <note> <p>If you specify a waypoint position that\'s not located on a road, Amazon Location <a href="https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html">moves the position to the nearest road</a>. </p> <p>Specifying more than 23 waypoints returns a <code>400 ValidationException</code> error.</p> <p>If Esri is the provider for your route calculator, specifying a route that is longer than 400 km returns a <code>400 RoutesValidationException</code> error.</p> </note> <p>Valid Values: <code>[-180 to 180,-90 to 90]</code> </p>',
        max_length=23,
        min_length=0,
    )


class RoutesV0CalculatorsCalculatorNameCalculateRouteMatrixPostRequest(BaseModel):
    CarModeOptions_1: Optional[CarModeOptions] = Field(
        None,
        alias='CarModeOptions',
        description='Contains details about additional route preferences for requests that specify <code>TravelMode</code> as <code>Car</code>.',
    )
    DepartNow: Optional[bool] = Field(
        None,
        description="<p>Sets the time of departure as the current time. Uses the current time to calculate the route matrix. You can't set both <code>DepartureTime</code> and <code>DepartNow</code>. If neither is set, the best time of day to travel with the best traffic conditions is used to calculate the route matrix.</p> <p>Default Value: <code>false</code> </p> <p>Valid Values: <code>false</code> | <code>true</code> </p>",
    )
    DeparturePositions: List[Position] = Field(
        ...,
        description='<p>The list of departure (origin) positions for the route matrix. An array of points, each of which is itself a 2-value array defined in <a href="https://earth-info.nga.mil/GandG/wgs84/index.html">WGS 84</a> format: <code>[longitude, latitude]</code>. For example, <code>[-123.115, 49.285]</code>.</p> <important> <p>Depending on the data provider selected in the route calculator resource there may be additional restrictions on the inputs you can choose. See <a href="https://docs.aws.amazon.com/location/latest/developerguide/calculate-route-matrix.html#matrix-routing-position-limits"> Position restrictions</a> in the <i>Amazon Location Service Developer Guide</i>.</p> </important> <note> <p>For route calculators that use Esri as the data provider, if you specify a departure that\'s not located on a road, Amazon Location <a href="https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html"> moves the position to the nearest road</a>. The snapped value is available in the result in <code>SnappedDeparturePositions</code>.</p> </note> <p>Valid Values: <code>[-180 to 180,-90 to 90]</code> </p>',
        max_length=350,
        min_length=1,
    )
    DepartureTime: Optional[datetime] = Field(
        None,
        description='<p>Specifies the desired time of departure. Uses the given time to calculate the route matrix. You can\'t set both <code>DepartureTime</code> and <code>DepartNow</code>. If neither is set, the best time of day to travel with the best traffic conditions is used to calculate the route matrix.</p> <note> <p>Setting a departure time in the past returns a <code>400 ValidationException</code> error.</p> </note> <ul> <li> <p>In <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601</a> format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>. For example, <code>2020–07-2T12:15:20.000Z+01:00</code> </p> </li> </ul>',
    )
    DestinationPositions: List[Position] = Field(
        ...,
        description='<p>The list of destination positions for the route matrix. An array of points, each of which is itself a 2-value array defined in <a href="https://earth-info.nga.mil/GandG/wgs84/index.html">WGS 84</a> format: <code>[longitude, latitude]</code>. For example, <code>[-122.339, 47.615]</code> </p> <important> <p>Depending on the data provider selected in the route calculator resource there may be additional restrictions on the inputs you can choose. See <a href="https://docs.aws.amazon.com/location/latest/developerguide/calculate-route-matrix.html#matrix-routing-position-limits"> Position restrictions</a> in the <i>Amazon Location Service Developer Guide</i>.</p> </important> <note> <p>For route calculators that use Esri as the data provider, if you specify a destination that\'s not located on a road, Amazon Location <a href="https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html"> moves the position to the nearest road</a>. The snapped value is available in the result in <code>SnappedDestinationPositions</code>.</p> </note> <p>Valid Values: <code>[-180 to 180,-90 to 90]</code> </p>',
        max_length=350,
        min_length=1,
    )
    DistanceUnit_1: Optional[DistanceUnit] = Field(
        None,
        alias='DistanceUnit',
        description='<p>Set the unit system to specify the distance.</p> <p>Default Value: <code>Kilometers</code> </p>',
    )
    TravelMode_1: Optional[TravelMode] = Field(
        None,
        alias='TravelMode',
        description='<p>Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility.</p> <p>The <code>TravelMode</code> you specify also determines how you specify route preferences: </p> <ul> <li> <p>If traveling by <code>Car</code> use the <code>CarModeOptions</code> parameter.</p> </li> <li> <p>If traveling by <code>Truck</code> use the <code>TruckModeOptions</code> parameter.</p> </li> </ul> <note> <p> <code>Bicycle</code> or <code>Motorcycle</code> are only valid when using <code>Grab</code> as a data provider, and only within Southeast Asia.</p> <p> <code>Truck</code> is not available for Grab.</p> <p>For more information about using Grab as a data provider, see <a href="https://docs.aws.amazon.com/location/latest/developerguide/grab.html">GrabMaps</a> in the <i>Amazon Location Service Developer Guide</i>.</p> </note> <p>Default Value: <code>Car</code> </p>',
    )
    TruckModeOptions_1: Optional[TruckModeOptions] = Field(
        None,
        alias='TruckModeOptions',
        description='Contains details about additional route preferences for requests that specify <code>TravelMode</code> as <code>Truck</code>.',
    )


class ApiKeyRestrictions(BaseModel):
    AllowActions: ApiKeyRestrictionsAllowActionsList
    AllowReferers: Optional[ApiKeyRestrictionsAllowReferersList] = None
    AllowResources: ApiKeyRestrictionsAllowResourcesList


class BatchDeleteDevicePositionHistoryError(BaseModel):
    DeviceId: Id
    Error: BatchItemError


class BatchDeleteDevicePositionHistoryErrorList(
    RootModel[List[BatchDeleteDevicePositionHistoryError]]
):
    root: List[BatchDeleteDevicePositionHistoryError]


class BatchDeleteDevicePositionHistoryRequest(BaseModel):
    DeviceIds: BatchDeleteDevicePositionHistoryRequestDeviceIdsList


class BatchDeleteDevicePositionHistoryResponse(BaseModel):
    Errors: BatchDeleteDevicePositionHistoryErrorList


class BatchDeleteGeofenceError(BaseModel):
    Error: BatchItemError
    GeofenceId: Id


class BatchDeleteGeofenceErrorList(RootModel[List[BatchDeleteGeofenceError]]):
    root: List[BatchDeleteGeofenceError]


class BatchDeleteGeofenceRequest(BaseModel):
    GeofenceIds: BatchDeleteGeofenceRequestGeofenceIdsList


class BatchDeleteGeofenceResponse(BaseModel):
    Errors: BatchDeleteGeofenceErrorList


class BatchEvaluateGeofencesError(BaseModel):
    DeviceId: Id
    Error: BatchItemError
    SampleTime: Timestamp


class BatchEvaluateGeofencesErrorList(RootModel[List[BatchEvaluateGeofencesError]]):
    root: List[BatchEvaluateGeofencesError]


class BatchEvaluateGeofencesResponse(BaseModel):
    Errors: BatchEvaluateGeofencesErrorList


class BatchGetDevicePositionError(BaseModel):
    DeviceId: Id
    Error: BatchItemError


class BatchGetDevicePositionErrorList(RootModel[List[BatchGetDevicePositionError]]):
    root: List[BatchGetDevicePositionError]


class BatchGetDevicePositionRequest(BaseModel):
    DeviceIds: BatchGetDevicePositionRequestDeviceIdsList


class BatchPutGeofenceResponse(BaseModel):
    Errors: BatchPutGeofenceErrorList
    Successes: BatchPutGeofenceSuccessList


class CalculateRouteTruckModeOptions(BaseModel):
    AvoidFerries: Optional[Boolean] = None
    AvoidTolls: Optional[Boolean] = None
    Dimensions: Optional[TruckDimensions] = None
    Weight: Optional[TruckWeight] = None


class CreateGeofenceCollectionRequest(BaseModel):
    CollectionName: ResourceName
    Description: Optional[ResourceDescription] = None
    KmsKeyId_1: Optional[KmsKeyId] = Field(None, alias='KmsKeyId')
    PricingPlan_1: Optional[PricingPlan] = Field(None, alias='PricingPlan')
    PricingPlanDataSource: Optional[String] = None
    Tags: Optional[TagMap] = None


class CreateKeyRequest(BaseModel):
    Description: Optional[ResourceDescription] = None
    ExpireTime: Optional[Timestamp] = None
    KeyName: ResourceName
    NoExpiry: Optional[Boolean] = None
    Restrictions: ApiKeyRestrictions
    Tags: Optional[TagMap] = None


class CreateMapRequest(BaseModel):
    Configuration: MapConfiguration
    Description: Optional[ResourceDescription] = None
    MapName: ResourceName
    PricingPlan_1: Optional[PricingPlan] = Field(None, alias='PricingPlan')
    Tags: Optional[TagMap] = None


class CreatePlaceIndexRequest(BaseModel):
    DataSource: String
    DataSourceConfiguration_1: Optional[DataSourceConfiguration] = Field(
        None, alias='DataSourceConfiguration'
    )
    Description: Optional[ResourceDescription] = None
    IndexName: ResourceName
    PricingPlan_1: Optional[PricingPlan] = Field(None, alias='PricingPlan')
    Tags: Optional[TagMap] = None


class CreateRouteCalculatorRequest(BaseModel):
    CalculatorName: ResourceName
    DataSource: String
    Description: Optional[ResourceDescription] = None
    PricingPlan_1: Optional[PricingPlan] = Field(None, alias='PricingPlan')
    Tags: Optional[TagMap] = None


class CreateTrackerRequest(BaseModel):
    Description: Optional[ResourceDescription] = None
    KmsKeyId_1: Optional[KmsKeyId] = Field(None, alias='KmsKeyId')
    PositionFiltering_1: Optional[PositionFiltering] = Field(
        None, alias='PositionFiltering'
    )
    PricingPlan_1: Optional[PricingPlan] = Field(None, alias='PricingPlan')
    PricingPlanDataSource: Optional[String] = None
    Tags: Optional[TagMap] = None
    TrackerName: ResourceName


class DescribeGeofenceCollectionResponse(BaseModel):
    CollectionArn: Arn
    CollectionName: ResourceName
    CreateTime: Timestamp
    Description: ResourceDescription
    KmsKeyId_1: Optional[KmsKeyId] = Field(None, alias='KmsKeyId')
    PricingPlan_1: Optional[PricingPlan] = Field(None, alias='PricingPlan')
    PricingPlanDataSource: Optional[String] = None
    Tags: Optional[TagMap] = None
    UpdateTime: Timestamp


class DescribeKeyResponse(BaseModel):
    CreateTime: Timestamp
    Description: Optional[ResourceDescription] = None
    ExpireTime: Timestamp
    Key: ApiKey
    KeyArn: Arn
    KeyName: ResourceName
    Restrictions: ApiKeyRestrictions
    Tags: Optional[TagMap] = None
    UpdateTime: Timestamp


class DescribeMapResponse(BaseModel):
    Configuration: MapConfiguration
    CreateTime: Timestamp
    DataSource: String
    Description: ResourceDescription
    MapArn: GeoArn
    MapName: ResourceName
    PricingPlan_1: Optional[PricingPlan] = Field(None, alias='PricingPlan')
    Tags: Optional[TagMap] = None
    UpdateTime: Timestamp


class DescribePlaceIndexResponse(BaseModel):
    CreateTime: Timestamp
    DataSource: String
    DataSourceConfiguration_1: DataSourceConfiguration = Field(
        ..., alias='DataSourceConfiguration'
    )
    Description: ResourceDescription
    IndexArn: Arn
    IndexName: ResourceName
    PricingPlan_1: Optional[PricingPlan] = Field(None, alias='PricingPlan')
    Tags: Optional[TagMap] = None
    UpdateTime: Timestamp


class DescribeRouteCalculatorResponse(BaseModel):
    CalculatorArn: Arn
    CalculatorName: ResourceName
    CreateTime: Timestamp
    DataSource: String
    Description: ResourceDescription
    PricingPlan_1: Optional[PricingPlan] = Field(None, alias='PricingPlan')
    Tags: Optional[TagMap] = None
    UpdateTime: Timestamp


class DescribeTrackerResponse(BaseModel):
    CreateTime: Timestamp
    Description: ResourceDescription
    KmsKeyId_1: Optional[KmsKeyId] = Field(None, alias='KmsKeyId')
    PositionFiltering_1: Optional[PositionFiltering] = Field(
        None, alias='PositionFiltering'
    )
    PricingPlan_1: Optional[PricingPlan] = Field(None, alias='PricingPlan')
    PricingPlanDataSource: Optional[String] = None
    Tags: Optional[TagMap] = None
    TrackerArn: Arn
    TrackerName: ResourceName
    UpdateTime: Timestamp


class DevicePosition(BaseModel):
    Accuracy: Optional[PositionalAccuracy] = None
    DeviceId: Optional[Id] = None
    Position_1: Position = Field(..., alias='Position')
    PositionProperties: Optional[PropertyMap] = None
    ReceivedTime: Timestamp
    SampleTime: Timestamp


class DevicePositionList(RootModel[List[DevicePosition]]):
    root: List[DevicePosition]


class DevicePositionUpdate(BaseModel):
    Accuracy: Optional[PositionalAccuracy] = None
    DeviceId: Id
    Position_1: Position = Field(..., alias='Position')
    PositionProperties: Optional[PropertyMap] = None
    SampleTime: Timestamp


class GeofenceGeometry(BaseModel):
    Circle_1: Optional[Circle] = Field(None, alias='Circle')
    Polygon: Optional[LinearRings] = None


class GetDevicePositionHistoryResponse(BaseModel):
    DevicePositions: DevicePositionList
    NextToken: Optional[Token] = None


class GetDevicePositionResponse(BaseModel):
    Accuracy: Optional[PositionalAccuracy] = None
    DeviceId: Optional[Id] = None
    Position_1: Position = Field(..., alias='Position')
    PositionProperties: Optional[PropertyMap] = None
    ReceivedTime: Timestamp
    SampleTime: Timestamp


class GetGeofenceResponse(BaseModel):
    CreateTime: Timestamp
    GeofenceId: Id
    Geometry: GeofenceGeometry
    Status: String
    UpdateTime: Timestamp


class LegGeometry(BaseModel):
    LineString_1: Optional[LineString] = Field(None, alias='LineString')


class ListDevicePositionsResponseEntry(BaseModel):
    Accuracy: Optional[PositionalAccuracy] = None
    DeviceId: Id
    Position_1: Position = Field(..., alias='Position')
    PositionProperties: Optional[PropertyMap] = None
    SampleTime: Timestamp


class ListDevicePositionsResponseEntryList(
    RootModel[List[ListDevicePositionsResponseEntry]]
):
    root: List[ListDevicePositionsResponseEntry]


class ListGeofenceCollectionsResponse(BaseModel):
    Entries: ListGeofenceCollectionsResponseEntryList
    NextToken: Optional[Token] = None


class ListGeofenceResponseEntry(BaseModel):
    CreateTime: Timestamp
    GeofenceId: Id
    Geometry: GeofenceGeometry
    Status: String
    UpdateTime: Timestamp


class ListGeofenceResponseEntryList(RootModel[List[ListGeofenceResponseEntry]]):
    root: List[ListGeofenceResponseEntry]


class ListGeofencesResponse(BaseModel):
    Entries: ListGeofenceResponseEntryList
    NextToken: Optional[Token] = None


class ListKeysResponseEntry(BaseModel):
    CreateTime: Timestamp
    Description: Optional[ResourceDescription] = None
    ExpireTime: Timestamp
    KeyName: ResourceName
    Restrictions: ApiKeyRestrictions
    UpdateTime: Timestamp


class ListKeysResponseEntryList(RootModel[List[ListKeysResponseEntry]]):
    root: List[ListKeysResponseEntry]


class ListMapsResponse(BaseModel):
    Entries: ListMapsResponseEntryList
    NextToken: Optional[Token] = None


class ListPlaceIndexesResponse(BaseModel):
    Entries: ListPlaceIndexesResponseEntryList
    NextToken: Optional[Token] = None


class ListRouteCalculatorsResponse(BaseModel):
    Entries: ListRouteCalculatorsResponseEntryList
    NextToken: Optional[Token] = None


class ListTagsForResourceResponse(BaseModel):
    Tags: Optional[TagMap] = None


class ListTrackersResponse(BaseModel):
    Entries: ListTrackersResponseEntryList
    NextToken: Optional[Token] = None


class Place(BaseModel):
    AddressNumber: Optional[String] = None
    Country: Optional[String] = None
    Geometry: PlaceGeometry
    Interpolated: Optional[Boolean] = None
    Label: Optional[String] = None
    Municipality: Optional[String] = None
    Neighborhood: Optional[String] = None
    PostalCode: Optional[String] = None
    Region: Optional[String] = None
    Street: Optional[String] = None
    SubRegion: Optional[String] = None
    TimeZone_1: Optional[TimeZone] = Field(None, alias='TimeZone')
    UnitNumber: Optional[String] = None
    UnitType: Optional[String] = None


class PutGeofenceRequest(BaseModel):
    Geometry: GeofenceGeometry


class RouteMatrixEntry(BaseModel):
    Distance: Optional[RouteMatrixEntryDistanceDouble] = None
    DurationSeconds: Optional[RouteMatrixEntryDurationSecondsDouble] = None
    Error: Optional[RouteMatrixEntryError] = None


class RouteMatrixRow(RootModel[List[RouteMatrixEntry]]):
    root: List[RouteMatrixEntry]


class SearchForPositionResult(BaseModel):
    Distance: SearchForPositionResultDistanceDouble
    Place_1: Place = Field(..., alias='Place')
    PlaceId_1: Optional[PlaceId] = Field(None, alias='PlaceId')


class SearchForPositionResultList(RootModel[List[SearchForPositionResult]]):
    root: List[SearchForPositionResult]


class SearchForTextResult(BaseModel):
    Distance: Optional[SearchForTextResultDistanceDouble] = None
    Place_1: Place = Field(..., alias='Place')
    PlaceId_1: Optional[PlaceId] = Field(None, alias='PlaceId')
    Relevance: Optional[SearchForTextResultRelevanceDouble] = None


class SearchForTextResultList(RootModel[List[SearchForTextResult]]):
    root: List[SearchForTextResult]


class SearchPlaceIndexForPositionResponse(BaseModel):
    Results: SearchForPositionResultList
    Summary: SearchPlaceIndexForPositionSummary


class SearchPlaceIndexForSuggestionsResponse(BaseModel):
    Results: SearchForSuggestionsResultList
    Summary: SearchPlaceIndexForSuggestionsSummary


class SearchPlaceIndexForTextResponse(BaseModel):
    Results: SearchForTextResultList
    Summary: SearchPlaceIndexForTextSummary


class UpdateKeyRequest(BaseModel):
    Description: Optional[ResourceDescription] = None
    ExpireTime: Optional[Timestamp] = None
    ForceUpdate: Optional[Boolean] = None
    NoExpiry: Optional[Boolean] = None
    Restrictions: Optional[ApiKeyRestrictions] = None


class GeofencingV0CollectionsCollectionNamePositionsPostRequest(BaseModel):
    DevicePositionUpdates: List[DevicePositionUpdate] = Field(
        ...,
        description='Contains device details for each device to be evaluated against the given geofence collection.',
        max_length=10,
        min_length=1,
    )


class TrackingV0TrackersTrackerNamePositionsPostRequest(BaseModel):
    Updates: List[DevicePositionUpdate] = Field(
        ...,
        description='Contains the position update details for each device.',
        max_length=10,
        min_length=1,
    )


class BatchEvaluateGeofencesRequestDevicePositionUpdatesList(
    RootModel[List[DevicePositionUpdate]]
):
    root: List[DevicePositionUpdate] = Field(..., max_length=10, min_length=1)


class BatchGetDevicePositionResponse(BaseModel):
    DevicePositions: DevicePositionList
    Errors: BatchGetDevicePositionErrorList


class BatchPutGeofenceRequestEntry(BaseModel):
    GeofenceId: Id
    Geometry: GeofenceGeometry


class BatchUpdateDevicePositionRequestUpdatesList(
    RootModel[List[DevicePositionUpdate]]
):
    root: List[DevicePositionUpdate] = Field(..., max_length=10, min_length=1)


class CalculateRouteMatrixRequest(BaseModel):
    CarModeOptions: Optional[CalculateRouteCarModeOptions] = None
    DepartNow: Optional[Boolean] = None
    DeparturePositions: CalculateRouteMatrixRequestDeparturePositionsList
    DepartureTime: Optional[Timestamp] = None
    DestinationPositions: CalculateRouteMatrixRequestDestinationPositionsList
    DistanceUnit_1: Optional[DistanceUnit] = Field(None, alias='DistanceUnit')
    TravelMode_1: Optional[TravelMode] = Field(None, alias='TravelMode')
    TruckModeOptions: Optional[CalculateRouteTruckModeOptions] = None


class CalculateRouteRequest(BaseModel):
    CarModeOptions: Optional[CalculateRouteCarModeOptions] = None
    DepartNow: Optional[Boolean] = None
    DeparturePosition: Position
    DepartureTime: Optional[Timestamp] = None
    DestinationPosition: Position
    DistanceUnit_1: Optional[DistanceUnit] = Field(None, alias='DistanceUnit')
    IncludeLegGeometry: Optional[Boolean] = None
    TravelMode_1: Optional[TravelMode] = Field(None, alias='TravelMode')
    TruckModeOptions: Optional[CalculateRouteTruckModeOptions] = None
    WaypointPositions: Optional[CalculateRouteRequestWaypointPositionsList] = None


class GetPlaceResponse(BaseModel):
    Place_1: Place = Field(..., alias='Place')


class Leg(BaseModel):
    Distance: LegDistanceDouble
    DurationSeconds: LegDurationSecondsDouble
    EndPosition: Position
    Geometry: Optional[LegGeometry] = None
    StartPosition: Position
    Steps: StepList


class LegList(RootModel[List[Leg]]):
    root: List[Leg]


class ListDevicePositionsResponse(BaseModel):
    Entries: ListDevicePositionsResponseEntryList
    NextToken: Optional[Token] = None


class ListKeysResponse(BaseModel):
    Entries: ListKeysResponseEntryList
    NextToken: Optional[Token] = None


class RouteMatrix(RootModel[List[RouteMatrixRow]]):
    root: List[RouteMatrixRow]


class GeofencingV0CollectionsCollectionNamePutGeofencesPostRequest(BaseModel):
    Entries: List[BatchPutGeofenceRequestEntry] = Field(
        ...,
        description='The batch of geofences to be stored in a geofence collection.',
        max_length=10,
        min_length=1,
    )


class BatchEvaluateGeofencesRequest(BaseModel):
    DevicePositionUpdates: BatchEvaluateGeofencesRequestDevicePositionUpdatesList


class BatchPutGeofenceRequestEntriesList(RootModel[List[BatchPutGeofenceRequestEntry]]):
    root: List[BatchPutGeofenceRequestEntry] = Field(..., max_length=10, min_length=1)


class BatchUpdateDevicePositionRequest(BaseModel):
    Updates: BatchUpdateDevicePositionRequestUpdatesList


class CalculateRouteMatrixResponse(BaseModel):
    RouteMatrix_1: RouteMatrix = Field(..., alias='RouteMatrix')
    SnappedDeparturePositions: Optional[
        CalculateRouteMatrixResponseSnappedDeparturePositionsList
    ] = None
    SnappedDestinationPositions: Optional[
        CalculateRouteMatrixResponseSnappedDestinationPositionsList
    ] = None
    Summary: CalculateRouteMatrixSummary


class CalculateRouteResponse(BaseModel):
    Legs: LegList
    Summary: CalculateRouteSummary


class BatchPutGeofenceRequest(BaseModel):
    Entries: BatchPutGeofenceRequestEntriesList
